import math
import random
import datetime


class PriceSimulator:
    """
    A class for simulating price data with noise and spikes.

    Methods:
    - price_envelope(num_intervals, min_price, max_price, peak_start, peak_end, date): Generate price data with a smooth envelope curve for peak and off-peak prices and adds randomness based on a date seed.
    - add_noise_and_spikes(prices, noise_level, spike_chance, spike_multiplier): Adds random noise and occasional spikes to the prices.
    """

    @staticmethod
    def price_envelope(
        num_intervals=24,
        min_price=0,
        max_price=200,
        peak_start=16,
        peak_end=32,
        date=datetime.date.today(),
    ) -> list:
        """
        Generate price data with a smooth envelope curve for peak and off-peak prices, adding randomness based on a date seed.

        Parameters:
        - num_intervals (int): The number of price intervals (assuming 1 price point per hour for a 24-hour day).
        - min_price (float): The minimum price during off-peak hours.
        - max_price (float): The maximum price during peak hours.
        - peak_start (int): The interval index for the start of peak pricing.
        - peak_end (int): The interval index for the end of peak pricing.
        - date (datetime.date): The date used as a seed for randomness.

        Returns:
        List[float]: A list of prices with a smooth transition between off-peak and peak hours, with added randomness.
        """
        # Use the date as a seed for randomness
        random.seed(date.toordinal())

        prices = []
        for i in range(num_intervals):
            # Calculate the position of the current interval within the cycle
            x = (math.pi * 2) * (i / num_intervals)

            # Adjust sine wave to create variations for both peak and off-peak hours
            if peak_start <= i < peak_end:
                # More pronounced sine wave for peak hours
                sine_value = (
                    math.sin(x - math.pi / 2) + 1
                ) / 2  # Scale sine wave to [0, 1]
                price = min_price + (max_price - min_price) * sine_value
            else:
                # Subtler sine wave for off-peak hours to introduce variations
                off_peak_amplitude = (
                    max_price - min_price
                ) / 4  # Less variation in off-peak hours
                sine_value = (
                    math.sin(x * 2 - math.pi / 2) + 1
                ) / 2  # Double the frequency for more fluctuations
                price = min_price + off_peak_amplitude * sine_value

            # Introduce randomness
            random_adjustment = (
                random.uniform(-1, 1) * (max_price - min_price) / 20
            )  # Adjust the scale of randomness
            price += random_adjustment

            # Ensure price stays within min and max bounds
            price = max(min_price, min(price, max_price))

            prices.append(price)
        return prices

    @staticmethod
    def add_noise_and_spikes(
        prices, noise_level=5, spike_chance=0.05, spike_multiplier=1.5
    ):
        """
        Adds random noise and occasional spikes to the prices.

        Parameters:
        - prices (list): The original list of prices generated by price_envelope.
        - noise_level (float): The maximum deviation added as noise to each price point.
        - spike_chance (float): The probability of a price spike occurring at any interval.
        - spike_multiplier (float): The factor by which prices increase during a spike.

        Returns:
        List[float]: The modified list of prices with added noise and spikes.
        """
        noisy_prices = []
        for price in prices:
            # Add random noise
            noise = random.uniform(-noise_level, noise_level)
            new_price = price + noise

            # Randomly introduce spikes
            if random.random() < spike_chance:
                new_price *= spike_multiplier

            # Ensure the price does not go negative
            new_price = max(0, new_price)
            noisy_prices.append(new_price)

        return noisy_prices
