import math
import random
import datetime
import pandas as pd
import pytz


class PriceSimulator:
    """
    A class for simulating price data with noise and spikes.

    Methods:
    - price_envelope(num_intervals, min_price, max_price, peak_start, peak_end, date): Generate price data with a smooth envelope curve for peak and off-peak prices and adds randomness based on a date seed.
    - add_noise_and_spikes(prices, noise_level, spike_chance, spike_multiplier): Adds random noise and occasional spikes to the prices.
    """

    @staticmethod
    def price_envelope(
        num_intervals=24,
        min_price=0,
        max_price=200,
        peak_start=16,
        peak_end=32,
        date=datetime.date.today(),
    ) -> list:
        """
        Generate price data with a smooth envelope curve for peak and off-peak prices, adding randomness based on a date seed.

        Parameters:
        - num_intervals (int): The number of price intervals (assuming 1 price point per hour for a 24-hour day).
        - min_price (float): The minimum price during off-peak hours.
        - max_price (float): The maximum price during peak hours.
        - peak_start (int): The interval index for the start of peak pricing.
        - peak_end (int): The interval index for the end of peak pricing.
        - date (datetime.date): The date used as a seed for randomness.

        Returns:
        List[float]: A list of prices with a smooth transition between off-peak and peak hours, with added randomness.
        """
        # Use the date as a seed for randomness
        random.seed(date.toordinal())

        prices = []
        for i in range(num_intervals):
            # Calculate the position of the current interval within the cycle
            x = (math.pi * 2) * (i / num_intervals)

            # Adjust sine wave to create variations for both peak and off-peak hours
            if peak_start <= i < peak_end:
                # More pronounced sine wave for peak hours
                sine_value = (
                    math.sin(x - math.pi / 2) + 1
                ) / 2  # Scale sine wave to [0, 1]
                price = min_price + (max_price - min_price) * sine_value
            else:
                # Subtler sine wave for off-peak hours to introduce variations
                off_peak_amplitude = (
                    max_price - min_price
                ) / 4  # Less variation in off-peak hours
                sine_value = (
                    math.sin(x * 2 - math.pi / 2) + 1
                ) / 2  # Double the frequency for more fluctuations
                price = min_price + off_peak_amplitude * sine_value

            # Introduce randomness
            random_adjustment = (
                random.uniform(-1, 1) * (max_price - min_price) / 20
            )  # Adjust the scale of randomness
            price += random_adjustment

            # Ensure price stays within min and max bounds
            price = max(min_price, min(price, max_price))

            prices.append(price)
        return prices

    @staticmethod
    def add_noise_and_spikes(
        prices, noise_level=5, spike_chance=0.05, spike_multiplier=1.5
    ):
        """
        Adds random noise and occasional spikes to the prices.

        Parameters:
        - prices (list): The original list of prices generated by price_envelope.
        - noise_level (float): The maximum deviation added as noise to each price point.
        - spike_chance (float): The probability of a price spike occurring at any interval.
        - spike_multiplier (float): The factor by which prices increase during a spike.

        Returns:
        List[float]: The modified list of prices with added noise and spikes.
        """
        noisy_prices = []
        for price in prices:
            # Add random noise
            noise = random.uniform(-noise_level, noise_level)
            new_price = price + noise

            # Randomly introduce spikes
            if random.random() < spike_chance:
                new_price *= spike_multiplier

            # Ensure the price does not go negative
            new_price = max(0, new_price)
            noisy_prices.append(new_price)

        return noisy_prices



class PriceModel:
    def __init__(self, csv_file_path="data\\time_series\\time_series_60min_singleindex_filtered.csv"):
        # Read the CSV data into a DataFrame
        self.data = pd.read_csv(csv_file_path)
        # Convert the utc_timestamp column to datetime objects for easier manipulation
        self.data['utc_timestamp'] = pd.to_datetime(self.data['utc_timestamp'])

    def get_average_price_for_date(self, date_str):
        # Parse the given date
        if len(date_str) == 10:  # Only the date part is present
            date_str += "T00:00:00Z"

        # Parse the given date and make it timezone-aware
        current_date = datetime.datetime.strptime(date_str, '%Y-%m-%dT%H:%M:%SZ').replace(tzinfo=pytz.utc)
        week_prior = current_date - datetime.timedelta(days=7)

        # Filter the data for the last week
        last_week_data = self.data[(self.data['utc_timestamp'] >= week_prior) & 
                                   (self.data['utc_timestamp'] < current_date)]

        # Calculate the average price per hour for the last week
        average_prices_last_week = last_week_data.groupby(last_week_data['utc_timestamp'].dt.hour)['GB_GBN_price_day_ahead'].mean()

        # Filter the data for the current date
        current_date_data = self.data[self.data['utc_timestamp'].dt.date == current_date.date()]

        # Get the prices for each hour of the current date
        prices_current_date = current_date_data.set_index(current_date_data['utc_timestamp'].dt.hour)['GB_GBN_price_day_ahead']

        return list(average_prices_last_week.to_dict().values()), list(prices_current_date.to_dict().values())